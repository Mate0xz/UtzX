from sys import argv #module to read arguments
from sys import exit as leave #cuz exit() is a python function

help = """
LCM Calculator by wolfrust

Usage: LCM.py number1 number2 ....
Example: LCM.py 2 3.5 [output = 14.0]
"""

if len(argv) == 1: #if no arguments are given
    print(help)
    leave()

if argv[1] == "--help" or argv[1] == "-h" or argv[1] == "help":
    print(help)
    leave()


numbers = [] #holds float values of arguments given

for i in range(1, len(argv), 1):
    numbers.append(float(argv[i])) #append the float value of every argument to numbers

def AllSame(lis): #check if all elements in a list are the same
    init = lis[0]
    same = True

    for item in lis:
        if item != init:
            same = False

    return same

def genListGroup(length): #generate a list with <<length>> EMPTY lists inside it genListGroup(2) = [[][]]
    array = []
    count = 1
    while count <= length:
        array.append([])
        count += 1
    return array

def isset(val, arr): #check if value exists in array
    there = False
    for value in arr:
        if value == val:
            there = True
    return there

def gi(valx, grparr): #check if value exists in every list in a grouparray [here, generated by genListGroup()]
    bools = []
    for array in grparr: #for each array in the given grouparray
        if isset(valx, array): #check if given value exists
            bools.append(True) #if it does, append True to bools
        else:
            bools.append(False) #otherwise, append False
    ye = True #whether or not the $valx exists in every list in $grparr {not real value, just initializing it}
    for bool in bools: #check the value of every boolean
        if bool != True: #if any of them isn't true (meaning the value doesn't exist in one of the arrays)
            ye = False #set ye to False
    return ye #so if all of them were true, this won't change from it's initial value [True]

x = 0 #initialize counter

while True:
    main = genListGroup(len(numbers)) #each array in this grouparray holdes multiples a number (main[1] with hold multiples of numbers[1])
    possible = [] #holds common multiples
    sub = [] #used to hold every element in main except main[0]
    x += 100 #search for common multiples within the next 100 numbers, increment if the loop isn't broken at line 87

    for i in range(len(numbers)): #for every number
        for m in range(1, x, 1): #and this being the thing you multiply the number with
            main[i].append(m * numbers[i]) #write the product of the number and $m to the array at the same index of $main as the number's index in $numbers

    for i in range(1, len(main), 1):
        sub.append(main[i]) #we write every thing in main except main[0] to sub (you'll see why in the next step)

    for floatx in main[0]: #if a multiple of the first number
        if gi(floatx, sub): #is in every array in sub [that is to say, a multiple of every other number in $numbers] (~every other~ -> that's why we took sub as a seperate array without main[0])
            possible.append(floatx) #mark it as a common multiple

    if len(possible) != 0:
        #if len(possible) = 0, that means there were no common multiples.
        #So we repeat the process, but this time x gets incremented by 100, and we search in that range
        #it keeps going on and on like this until the range (say x = 1000, then the range is 1-1000) contains a common multiples
        #then, we break the loop (because we just need the lowest common multiple) [there's usually more than one value in possible.. we'll get to that]
        break

print("\n-------------------------------------------------\n")
print(f"\tLCM of {numbers} : [{min(possible)}]") # min(possible) -> get the lowest common multiple (LCM)
print("\n-------------------------------------------------")
